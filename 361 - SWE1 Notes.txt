361 - Software Engineering 1 notes

Week 1
===========================================================================================

SDLC - requirements -> design -> implementation -> testing -> maintenance

Software engineering is solving real world problems without making things worse or excessive costs by creating software

Software is not enough -> need people and context

System Boundary: software being developed

Great software has quality attributes:
	-> reliability
		-> consistency
		-> accuracy
		-> error tolerance

	-> efficiency
		-> execution efficiency
		-> storage efficiency

	-> integrity
		-> access control
		-> access audit

	-> usability
		-> operability
		-> training
		-> communicativeness

	-> maintainability
		-> simplicity
		-> conciseness
		-> instrumentation
		-> self-descriptiveness

	-> testability
		-> simplicity
		-> instrumentation
		-> self-descriptiveness
		-> modularity

	-> flexibility
		-> simplicity
		-> expandability
		-> generality
		-> modularity

	-> portability
		-> simplicity
		-> software system independence
		-> machine independence


	-> reusability
		-> simplicity
		-> generality
		-> modularity
		-> software system independence
		-> machine independence

	-> interoperability
		-> modularity
		-> communications commonality
		-> data commonality


	contains the right features for the right data:

		-> use cases - the activities a system supports
			e.g. tweet a vote reort, view delays on map

		-> entities - the kinds of objects that are involved in use cases
			e.g. tweets, user accounts, polling locations, maps

		-> attributes - the props of the netities
			e.g. tweets have: timestamp, text, sender

	* Need to understand what it should do before you can build a great system *

	

	Process: well defined and usually involves a set of tools and techniques
		-> set of ordered tasks

		SDLC:
			requirements
			design
			implementation
			testing
			operation

			Implied planning and risk mgmt

	Life-cycle: the process of building a product

	Requirements:
		-> talk to customers
		-> diagrams
		-> watch users, etc..


	Design:
		Architectural: Figuring out the overall STRUCTURE of the system
			-> what components?
			-> how should these be connected?

		Program: Figuring out how CODE should be organized
			-> how should each component's code be distributed among classes and/or functions


	Implementation:
		-> write code
		-> comments/other doc
		-> helping others/answering questions

	Testing:
		-> unit testing
			-> individual components

		-> system integration testing
			-> components that work well together

		-> usability testing
			-> good user interfaces

		-> acceptance testing
			-> customer/user happy?

	Operation:
		-> code complies, passes all test, looks good on desktop
		-> distrobution
		-> debugging after users
		-> post mortem


	-> iterative improvements
		-> whole system working pretty well then add features

	-> incremental improvements
		-> part of system working really well then add more parts

Waterfall:
	requirements analysis
	design
	implementation
	testing
	op/maint

	drawbacks:
		-> non-iterative: hard to handle changes

	-> moved more to a spiral kind of model now to address issues

	emphasis:
		-> simplicity
		-> traceability

	weakness:
		-> req/design mistakces costly

	style: 
		-> highly controlled
		-> high ceremony

	Good choice for small systems
		-> fully understand reqs


Spiral:

	emphasis:
		-> risk mgmt
		-> exploring alternatives

	weakness:
		-> exploring alternatives can be costly

	style: 
		-> moderately controlled
		-> moderate ceremony

	Good choice for larger systems with vague reqs
		-> many alternatives for designing and coding


Agile:
	-> customer provies info
	-> "spike" eval and control risk
	-> prioritize stories and plan
	-> write/run/mod unit tests
	-> implement
	-> sys and acceptance tests
	-> operation
	-> start again


	Methods/Examples:
		Extreme Programming (XP): focus on simplicity and rapid iteration

		Scrum: 30-day iterations
			-> multiple self-organizing teams
			-> daily "scrum" coordination

		Crystal: collection of approaches based on the notion that every project needs
				a unique set of policies and conventions


	emphasis:
		-> flexibility
		-> immediacy

	weakness:
		-> continual rework can be costly

	style: 
		-> rapid and organic
		-> low ceremony

	Good for rapidly create something very small, but useful, then expand














Week 3
--------------------------------------------------------------------------

Lecture 1: Requirements
-----------------------------------------------

Requiremenet analysis
	-> get customers to write down what they want
	-> talk and make diagrams
	-> watch users to see what they need
	-> gather and discuss


Good requirements:
	-> correct
	-> consistent
	-> unambiguous
	-> complete
	-> relevant
	-> testable
	-> traceable


Typical parts of reqs docs:

	Functional reqs:
		-> unstructured text
			written from:
				-> external viewpoint (reqs def)
					definition: stated from vpt of somebody outside the system
						-> the system is a black box with some interface
						-> emphasis on the role of the system

				-> system viewpoint (reqs specification)
					specification: stated vpt from somebody inside the system
						-> environment is accessed via inputs & outputs
						-> emphasis on how the system works

		-> use cases


	Non-Functional (quality) reqs:
		-> unstructured text
			-> fit criteria

	Diagrams
		-> Class diagrams and entity relationship diagrams
		-> dataflow, sequence, and state diagrams






























