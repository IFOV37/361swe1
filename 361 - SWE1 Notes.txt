361 - Software Engineering 1 notes

Week 1
===========================================================================================

SDLC - requirements -> design -> implementation -> testing -> maintenance

Software engineering is solving real world problems without making things worse or excessive costs by creating software

Software is not enough -> need people and context

System Boundary: software being developed

Great software has quality attributes:
	-> reliability
		-> consistency
		-> accuracy
		-> error tolerance

	-> efficiency
		-> execution efficiency
		-> storage efficiency

	-> integrity
		-> access control
		-> access audit

	-> usability
		-> operability
		-> training
		-> communicativeness

	-> maintainability
		-> simplicity
		-> conciseness
		-> instrumentation
		-> self-descriptiveness

	-> testability
		-> simplicity
		-> instrumentation
		-> self-descriptiveness
		-> modularity

	-> flexibility
		-> simplicity
		-> expandability
		-> generality
		-> modularity

	-> portability
		-> simplicity
		-> software system independence
		-> machine independence


	-> reusability
		-> simplicity
		-> generality
		-> modularity
		-> software system independence
		-> machine independence

	-> interoperability
		-> modularity
		-> communications commonality
		-> data commonality


	contains the right features for the right data:

		-> use cases - the activities a system supports
			e.g. tweet a vote reort, view delays on map

		-> entities - the kinds of objects that are involved in use cases
			e.g. tweets, user accounts, polling locations, maps

		-> attributes - the props of the netities
			e.g. tweets have: timestamp, text, sender

	* Need to understand what it should do before you can build a great system *

	

	Process: well defined and usually involves a set of tools and techniques
		-> set of ordered tasks

		SDLC:
			requirements
			design
			implementation
			testing
			operation

			Implied planning and risk mgmt

	Life-cycle: the process of building a product

	Requirements:
		-> talk to customers
		-> diagrams
		-> watch users, etc..


	Design:
		Architectural: Figuring out the overall STRUCTURE of the system
			-> what components?
			-> how should these be connected?

		Program: Figuring out how CODE should be organized
			-> how should each component's code be distributed among classes and/or functions


	Implementation:
		-> write code
		-> comments/other doc
		-> helping others/answering questions

	Testing:
		-> unit testing
			-> individual components

		-> system integration testing
			-> components that work well together

		-> usability testing
			-> good user interfaces

		-> acceptance testing
			-> customer/user happy?

	Operation:
		-> code complies, passes all test, looks good on desktop
		-> distrobution
		-> debugging after users
		-> post mortem


	-> iterative improvements
		-> whole system working pretty well then add features

	-> incremental improvements
		-> part of system working really well then add more parts

Waterfall:
	requirements analysis
	design
	implementation
	testing
	op/maint

	drawbacks:
		-> non-iterative: hard to handle changes

	-> moved more to a spiral kind of model now to address issues

	emphasis:
		-> simplicity
		-> traceability

	weakness:
		-> req/design mistakces costly

	style: 
		-> highly controlled
		-> high ceremony

	Good choice for small systems
		-> fully understand reqs


Spiral:

	emphasis:
		-> risk mgmt
		-> exploring alternatives

	weakness:
		-> exploring alternatives can be costly

	style: 
		-> moderately controlled
		-> moderate ceremony

	Good choice for larger systems with vague reqs
		-> many alternatives for designing and coding


Agile:
	-> customer provies info
	-> "spike" eval and control risk
	-> prioritize stories and plan
	-> write/run/mod unit tests
	-> implement
	-> sys and acceptance tests
	-> operation
	-> start again


	Methods/Examples:
		Extreme Programming (XP): focus on simplicity and rapid iteration

		Scrum: 30-day iterations
			-> multiple self-organizing teams
			-> daily "scrum" coordination

		Crystal: collection of approaches based on the notion that every project needs
				a unique set of policies and conventions


	emphasis:
		-> flexibility
		-> immediacy

	weakness:
		-> continual rework can be costly

	style: 
		-> rapid and organic
		-> low ceremony

	Good for rapidly create something very small, but useful, then expand



Week 2
--------------------------------------------------------------------------

Lecture 2.1: Project  (only 1 video this week)
-----------------------------------------------


Project will use methods:

	Waterfall model to dev reqs and preliminary design

	last 2 weeks will transition to spiral model to code part of the design


Need to know:
	-> Know the waterfall process
	-> Understand the assignment
	-> Divide the work among your teamates
	-> Make sure everyone is doing their part
	-> Check one another's work

Divide responsibilities





Week 3
--------------------------------------------------------------------------

Lecture 3.1: Requirements
-----------------------------------------------

Requiremenet analysis
	-> get customers to write down what they want
	-> talk and make diagrams
	-> watch users to see what they need
	-> gather and discuss


Good requirements:
	-> correct
	-> consistent
	-> unambiguous
	-> complete
	-> relevant
	-> testable
	-> traceable


Typical parts of reqs docs:

	Functional reqs:
		-> unstructured text
			written from:
				-> external viewpoint (reqs def)
					definition: stated from vpt of somebody outside the system
						-> the system is a black box with some interface
						-> emphasis on the role of the system

				-> system viewpoint (reqs specification)
					specification: stated vpt from somebody inside the system
						-> environment is accessed via inputs & outputs
						-> emphasis on how the system works

		-> use cases
			-> describes activity supported by the system
				-> each use case describes a way to use the system
			-> each use case is like a "bundle of scenarios" that are all
				the same except for very minor details
			-> a little more formal and precise than unstructure text

Use case: (basic)

	name: succint and meaningful

	actor: who does the act

	preconditions: true b4 act?

	post cond: true after act?

	flow of events: steps




	Non-Functional (quality) reqs:  How well the system should do stuff
		-> unstructured text
			-> fit criteria
				-> exactly how good does the system need to be?
				-> driven by customer needs


				quality attribute examples:
					-> system must ask for tweet clarification w/in 5 mins
						-> user probably still online

					-> drawbridge must rise w/in 1min
						-> so traffic only stops 5 mins (1+1 + 3ship)

					-> at least 95% of the code must be Java
						-> porting apps to linux has proven to cost only $xxxx in the past

	Diagrams
		-> Class diagrams and entity relationship diagrams
		-> dataflow, sequence, and state diagrams

		use case diagram: shows supported activites

		UML class and entity-relationship diagrams: show entites, attributes, and relationships

		dataflow diagram: shows flo of information

		message sequence diagram: shows flow of control

		state chart: shows change over time



Lecture 3.2: Notations
-----------------------------------------------


	Diagrams
		-> Class diagrams and entity relationship diagrams
		-> dataflow, sequence, and state diagrams

		use case diagram: shows supported activites

		UML class and entity-relationship diagrams: show entites, attributes, and relationships

		UML class diag:
			User has twitter username
			repression tweet has user, when (datetime), and text (string)
			repression report has source (tweet) location (geocode) when (datetime), and details (string)
			etc...  Also has 1 to *, 1 to 1, * to *, etc.. 
				-> can show system boundaries via "container"

			-> 1 box / kind of entity, listing attributes

			-> lines w/out arrowheads show references, lbl'd w/ cardinality

			-> lines w/ hollow arrowheads for specilization

			-> lines w/ reg ah's use to indicate dependencies

		ERD:
			-> similar to UML, but:
				-> branches for entites
				-> diamond for relationships
				-> num or vars on lines show cardinality
				-> one box per kind of entity


		dataflow diagram: shows flow of information

			-> like a flowchart but not necessarily in a top down order
			-> lacks some info where things go

			-> helps to do a separate data flow for each use case

			-> oval is a "function" provided by system
				-> each inward arrow is a parm
				-> outward arrow is output


			-> each rectangle is an actor
				-> person, place, or thing that can do stuff to ini events

			-> half rectangle = data store (file or db)


		message sequence diagram: shows flow of control
			-> kind of likc job scheduling or a burndown chart

			-> dashed arrow for info back

		state chart: shows change over time
			-> general and a very basic idea of the status



Lecture 3.3: Example Requirements
-----------------------------------------------

Nothing




Lecture 3.4: Evaluate/ion Requirements
-----------------------------------------------

Validation: build the right system
	-> reqs def accurately reflect the customers needs?

Verification: build the system tright
	-> confirm that 1 doc or artifact conforms to another
		-> does code match design?
		-> design match spec?
		-> spec match def?



	How do we eval reqs?
		-> paper prototyping
		-> formal analysis
		etc..



	Prototyping:
		-> you depict what you think the system should look like
		-> you test the prototypes
		-> fix up the prototypes

		kinds/types:
			fidelity = fi = closeness to what the ultimate product would look like

			throwaway
				-> paper, lo-fi (photoshopped)
							-> photoshop, ppt, html

			evolutionary
				-> hi-fi (implemented on target platform)
					-> not fully functional, but incop'd into final product
					-> 


			stakeholder review
				-> sit down with s/hs
				-> eng present understanding
				-> stake correct undstng
				-> discuss
				-> revision

			Manual analysis
				->systematically check consistency

			formal analysis
				-> the one we are doing for hwk 1
					(req def, req spec)
				-> very expensive
				




Week 4
--------------------------------------------------------------------------

Lecture 4.1: Architecture
-----------------------------------------------

	-> shows pieces of a system and their relationships


component: self-containted piece of a system, w/ clearly defined interfaces

connector = a linkage b/w components via an interface


Architectural Style
	-> cerain archs occur over and over
		-> certain kinds of comps and conns
		-> certain typical arrangements



	user <-> website <-> db1
				|
				db2

		-> could be just about any web app

Common design:

Client-Server:
	
	Server = component that provices services
	Client = comp that interacts with user and calls server

	Typical setup:  user <-> client <-> server

Peer to peer:

	peer = comp provices svrs and may signal other peers

Publish-Subscribe:

	publish = comp advertses that it can sent certain events

	subscribe = a comp registers to rec certain events



pipe and filter:
	filter = comp that transforms data

	pipe = con that passes data b/w filters


Layering = comp provices svrcs to the next layer
	-> comps "hide" lower layers





Lecture 4.2: Architecture Decomposition
-----------------------------------------------

Decomposition: providing a detailed view of a component


Approaches for decomposing an arch:
	-> functional
			break req into fns, then break recursively into sub fns
				-> one comp per fn

			each fn computationally combines the output of sub fns

	-> data-oriented
			identify data structs in reqs break down recursively
				-> one comp per d/s

			each data s contains part of the data

	-> object-oriented
			identify d/s aligned w/ fns in reqs, recursive breakdown
				-> one class comp per data + fn package

			each comp contains part of the data+fns

	-> process-oriented
			break reqs into steps, then into sub steps recursively
				-> 1 cmp per sub step

			each sub step completes one part of a task

	-> feature-oriented
			break reqs into services, then svrcs into features
				-> 1 cmp per service or feature

			each feature makes the service "a little better"

	-> event-oriented
			break reqs into systems of events, then into sub events and state changes
				-> each comp receives and sends certain events,
				and manages certain state changes

			each component is like a stateful agent




Lecture 4.2: Architecture Evaluation
-----------------------------------------------

4 basic ways to eval arch designs

	1) compare against desired quality attributes
		maintainability
			-> how hard will it be to make anticipated changes?

		efficiency
			-> can system respond quickly?

		reliability
			-> will it perform properly under assumed conditions?

		integrity
			-> possible to put system in bad state?

		usability
			-> can real users complete their gaosl with the system?

		testability
			-> can you (semi-)auto test if the system is right?

		flexibility
			-> how easily can the system adapt to unusual conditions?

		portability
			-> could you get the system to run on a new platform?

		reusability
			-> what parts of the system could you use in a new system?

		interoperability
			-> can the sysm talk to other relevant systems?

			
	2) check for problematic failure modes

	3) Walk through use cases

	4) Verify conformatnce to checklist of principles





Week 6
--------------------------------------------------------------------------

Lecture 5.1: Object-Oriented Design
-----------------------------------------------

Objects have a concern in the sense that they have a purpose

Each class should have a clearly focused purpose
	-> each member usually corresponsd to 1 attribute
	-> only related items w/in class

	i) same for packages


copuling: when one module is involved in anothers modules concern
	-> reduces maintainability

cohesion: when a module is devoted to its concern
	-> increases maintainability
		i) functional (best)
			->work together for 1 purpose
		ii) communication
			-> use same data
		iii) procedural
			-> A, then B, vaguely related purpose
		iv) temporal
			-> A, then B, not related purpose
		v) logical
			-> either A or B might be executed
		vi) coincidental (worst)

tip: split modules to reduce cycles

tip: in reuse, prefer composition over inheritance
	-> in general, use comp to add features or to reuse code
	-> inheritance to add a new version of an entity

Interface is a promise
	-> publicly available information of the class

incremental dev: much of systems value resides in one subsection

iterative dev: value spread out over much of the system







Use UML diagrams
	-> one box per kind of entity
	-> lines w/o arrowheads show refs
	-> lines w/ open ah's for specialization
	-> lines w/ reg ah's indicate dependencies



Lecture 5.2: Design Patterns
-----------------------------------------------
	-> strategies for your "toolkit of ideas"
	-> templates for solutions
	-> codified best practices
	-> recognizable based on structure and purpose


Builder: knows how to create a complex obj
	-> insatntiating requires filling it with parts or lengthy config

Adapter: translates one interface to another by wrapping
	-> overcomes incompatibility

Facade: object that provices a unified, high lvl interface to a subsystem
	-> used when calling a subsys reqs a frequent series of copmlex lines of code

Memento: encapsulate state in an obj
	-> if you might want to rtn a certain state later	

Interpreter: parses and acts on instructions written in a certain syntax
	-> add scriptability

Observer: watching for another object to change state
	-> maintains a list of observers and notifies them
	-> used in event driven design





Lecture 5.3: Design Patterns 2
-----------------------------------------------

Template method: breaks an algorithm into steps
	-> children inherit and override any step they need to change
	-> useful if a gen algo can be mod'd slightly and reused

Factory method: define an interface for creating an obj
	-> let the classes that implement the interface decide which class to instantiate
	-> lets a class defer instantiation to sub classes

Strategy: allows for the selection of algo at runtime

Decorator: useful for assigning behavior at runtime indply of other instances of the same class
	-> allows multiple decorations per class

Composite: allows for reduction of complexity by dealing with a group of objs as a single obj

Visitor: allows for separation of the algo and the data it works on
	-> built on method overloading and dynamic types





hwk 4 contribs:

Contributed the selections for interfaces we want to show.  Provided the information that our design is incremental until the underlying structure is complete, then we switch to iterative development.


Head First Design Patterns Notes:



Week 7
--------------------------------------------------------------------------

Lecture 6.1: Agile Overview
-----------------------------------------------







Lecture 6.2: Customer Collaboration
-----------------------------------------------





Lecture 6.3: Individual Interactions
-----------------------------------------------

























