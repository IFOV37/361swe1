361 - Software Engineering 1 notes

Week 1
===========================================================================================

SDLC - requirements -> design -> implementation -> testing -> maintenance

Software engineering is solving real world problems without making things worse or excessive costs by creating software

Software is not enough -> need people and context

System Boundary: software being developed

Great software has quality attributes:
	-> reliability
		-> consistency
		-> accuracy
		-> error tolerance

	-> efficiency
		-> execution efficiency
		-> storage efficiency

	-> integrity
		-> access control
		-> access audit

	-> usability
		-> operability
		-> training
		-> communicativeness

	-> maintainability
		-> simplicity
		-> conciseness
		-> instrumentation
		-> self-descriptiveness

	-> testability
		-> simplicity
		-> instrumentation
		-> self-descriptiveness
		-> modularity

	-> flexibility
		-> simplicity
		-> expandability
		-> generality
		-> modularity

	-> portability
		-> simplicity
		-> software system independence
		-> machine independence


	-> reusability
		-> simplicity
		-> generality
		-> modularity
		-> software system independence
		-> machine independence

	-> interoperability
		-> modularity
		-> communications commonality
		-> data commonality


	contains the right features for the right data:

		-> use cases - the activities a system supports
			e.g. tweet a vote reort, view delays on map

		-> entities - the kinds of objects that are involved in use cases
			e.g. tweets, user accounts, polling locations, maps

		-> attributes - the props of the netities
			e.g. tweets have: timestamp, text, sender

	* Need to understand what it should do before you can build a great system *

	

	Process: well defined and usually involves a set of tools and techniques
		-> set of ordered tasks

		SDLC:
			requirements
			design
			implementation
			testing
			operation

			Implied planning and risk mgmt

	Life-cycle: the process of building a product

	Requirements:
		-> talk to customers
		-> diagrams
		-> watch users, etc..


	Design:
		Architectural: Figuring out the overall STRUCTURE of the system
			-> what components?
			-> how should these be connected?

		Program: Figuring out how CODE should be organized
			-> how should each component's code be distributed among classes and/or functions


	Implementation:
		-> write code
		-> comments/other doc
		-> helping others/answering questions

	Testing:
		-> unit testing
			-> individual components

		-> system integration testing
			-> components that work well together

		-> usability testing
			-> good user interfaces

		-> acceptance testing
			-> customer/user happy?

	Operation:
		-> code complies, passes all test, looks good on desktop
		-> distrobution
		-> debugging after users
		-> post mortem


	-> iterative improvements
		-> whole system working pretty well then add features

	-> incremental improvements
		-> part of system working really well then add more parts

Waterfall:
	requirements analysis
	design
	implementation
	testing
	op/maint

	drawbacks:
		-> non-iterative: hard to handle changes

	-> moved more to a spiral kind of model now to address issues

	emphasis:
		-> simplicity
		-> traceability

	weakness:
		-> req/design mistakces costly

	style: 
		-> highly controlled
		-> high ceremony

	Good choice for small systems
		-> fully understand reqs


Spiral:

	emphasis:
		-> risk mgmt
		-> exploring alternatives

	weakness:
		-> exploring alternatives can be costly

	style: 
		-> moderately controlled
		-> moderate ceremony

	Good choice for larger systems with vague reqs
		-> many alternatives for designing and coding


Agile:
	-> customer provies info
	-> "spike" eval and control risk
	-> prioritize stories and plan
	-> write/run/mod unit tests
	-> implement
	-> sys and acceptance tests
	-> operation
	-> start again


	Methods/Examples:
		Extreme Programming (XP): focus on simplicity and rapid iteration

		Scrum: 30-day iterations
			-> multiple self-organizing teams
			-> daily "scrum" coordination

		Crystal: collection of approaches based on the notion that every project needs
				a unique set of policies and conventions


	emphasis:
		-> flexibility
		-> immediacy

	weakness:
		-> continual rework can be costly

	style: 
		-> rapid and organic
		-> low ceremony

	Good for rapidly create something very small, but useful, then expand



Week 2
--------------------------------------------------------------------------

Lecture 2.1: Project  (only 1 video this week)
-----------------------------------------------


Project will use methods:

	Waterfall model to dev reqs and preliminary design

	last 2 weeks will transition to spiral model to code part of the design


Need to know:
	-> Know the waterfall process
	-> Understand the assignment
	-> Divide the work among your teamates
	-> Make sure everyone is doing their part
	-> Check one another's work

Divide responsibilities





Week 3
--------------------------------------------------------------------------

Lecture 3.1: Requirements
-----------------------------------------------

Requiremenet analysis
	-> get customers to write down what they want
	-> talk and make diagrams
	-> watch users to see what they need
	-> gather and discuss


Good requirements:
	-> correct
	-> consistent
	-> unambiguous
	-> complete
	-> relevant
	-> testable
	-> traceable


Typical parts of reqs docs:

	Functional reqs:
		-> unstructured text
			written from:
				-> external viewpoint (reqs def)
					definition: stated from vpt of somebody outside the system
						-> the system is a black box with some interface
						-> emphasis on the role of the system

				-> system viewpoint (reqs specification)
					specification: stated vpt from somebody inside the system
						-> environment is accessed via inputs & outputs
						-> emphasis on how the system works

		-> use cases
			-> describes activity supported by the system
				-> each use case describes a way to use the system
			-> each use case is like a "bundle of scenarios" that are all
				the same except for very minor details
			-> a little more formal and precise than unstructure text

Use case: (basic)

	name: succint and meaningful

	actor: who does the act

	preconditions: true b4 act?

	post cond: true after act?

	flow of events: steps




	Non-Functional (quality) reqs:  How well the system should do stuff
		-> unstructured text
			-> fit criteria
				-> exactly how good does the system need to be?
				-> driven by customer needs


				quality attribute examples:
					-> system must ask for tweet clarification w/in 5 mins
						-> user probably still online

					-> drawbridge must rise w/in 1min
						-> so traffic only stops 5 mins (1+1 + 3ship)

					-> at least 95% of the code must be Java
						-> porting apps to linux has proven to cost only $xxxx in the past

	Diagrams
		-> Class diagrams and entity relationship diagrams
		-> dataflow, sequence, and state diagrams

		use case diagram: shows supported activites

		UML class and entity-relationship diagrams: show entites, attributes, and relationships

		dataflow diagram: shows flo of information

		message sequence diagram: shows flow of control

		state chart: shows change over time



Lecture 3.2: Notations
-----------------------------------------------


	Diagrams
		-> Class diagrams and entity relationship diagrams
		-> dataflow, sequence, and state diagrams

		use case diagram: shows supported activites

		UML class and entity-relationship diagrams: show entites, attributes, and relationships

		UML class diag:
			User has twitter username
			repression tweet has user, when (datetime), and text (string)
			repression report has source (tweet) location (geocode) when (datetime), and details (string)
			etc...  Also has 1 to *, 1 to 1, * to *, etc.. 
				-> can show system boundaries via "container"

			-> 1 box / kind of entity, listing attributes

			-> lines w/out arrowheads show references, lbl'd w/ cardinality

			-> lines w/ hollow arrowheads for specilization

			-> lines w/ reg ah's use to indicate dependencies

		ERD:
			-> similar to UML, but:
				-> branches for entites
				-> diamond for relationships
				-> num or vars on lines show cardinality
				-> one box per kind of entity


		dataflow diagram: shows flow of information

			-> like a flowchart but not necessarily in a top down order
			-> lacks some info where things go

			-> helps to do a separate data flow for each use case

			-> oval is a "function" provided by system
				-> each inward arrow is a parm
				-> outward arrow is output


			-> each rectangle is an actor
				-> person, place, or thing that can do stuff to ini events

			-> half rectangle = data store (file or db)


		message sequence diagram: shows flow of control
			-> kind of likc job scheduling or a burndown chart

			-> dashed arrow for info back

		state chart: shows change over time
			-> general and a very basic idea of the status



Lecture 3.3: Example Requirements
-----------------------------------------------

Nothing




Lecture 3.4: Evaluate/ion Requirements
-----------------------------------------------

Validation: build the right system
	-> reqs def accurately reflect the customers needs?

Verification: build the system tright
	-> confirm that 1 doc or artifact conforms to another
		-> does code match design?
		-> design match spec?
		-> spec match def?



	How do we eval reqs?
		-> paper prototyping
		-> formal analysis
		etc..



	Prototyping:
		-> you depict what you think the system should look like
		-> you test the prototypes
		-> fix up the prototypes

		kinds/types:
			fidelity = fi = closeness to what the ultimate product would look like

			throwaway
				-> paper, lo-fi (photoshopped)
							-> photoshop, ppt, html

			evolutionary
				-> hi-fi (implemented on target platform)
					-> not fully functional, but incop'd into final product
					-> 


			stakeholder review
				-> sit down with s/hs
				-> eng present understanding
				-> stake correct undstng
				-> discuss
				-> revision

			Manual analysis
				->systematically check consistency

			formal analysis
				-> the one we are doing for hwk 1
					(req def, req spec)
				-> very expensive
				










